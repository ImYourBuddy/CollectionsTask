Compare collections.

1. LinkedList and ArrayList
Результаты:
Add first
ArrayList: 310963700
LinkedList:  4998800
Здесь результат ожидаемый, т.к. при вставке в начало ArrayList сдвигает все элементы, а LinkedList достаточно просто поменять ссылки.

Add last.
ArrayList:  2328700
LinkedList: 2319700
Показывают примерно одинаковый результат (одного порядка).

Add in the middle (Вставка в середину 10000 элементов)
Add in the middle
ArrayList:   287957600
LinkedList: 7952327800
Ожидалось, что LinkedList отработает быстрее, т. к. ArrayList нужно сдвигать половину элементов. Но при тестировании получалось, что ArrayList отрабатывает быстрее. Увеличивал 
размеры коллекций до 1000000, вставлял в середину от 1 до 10000, но все равно ArrayList оказывался быстрее. Могу это объяснить это только тем, что при указанных размерах 
ArrayList быстрее сдвигает элементы, чем LinkedList добирается до элемента, у которого нужно поменять ссылки. Но если смещать индекс ближе к началу, то LinkedList быстрее 
начинает отрабатывать.

Search by index from start
ArrayList: 814400
ArrayList: 517900

Search by index from middle
ArrayList:      287400
LinkedList: 6960075300

Search by index from end
ArrayList:   793400
LinkedList: 1095800

Search by value
ArrayList:  1431600
LinkedList: 1190000

При поиске по значению показывают примерно одинаковый результат, при поиске по индексу ArrayList намного быстрее, т.к. поддерживает произвольный доступ, кроме случаев, когда
индекс находится в начале, тогда LinkedList тоже быстро получает доступ.

Delete from start
ArrayList: 170631000
LinkedList:  1151500

Delete from middle
ArrayList: 1173800
LinkedList: 626800

Delete from end
ArrayList:    69398500
LinkedList: 4773251100
Здесь опять такая же ситуация, как со вставкой в середину. Если индекс находится ближе к началу, то LinkedList намного быстрее ArrayList и по мере увеличения индекса скорость 
работы выравнивается, а затем опять начинает лидировать ArrayList.

Выводы: Если при работе с коллекцией часто вставка элементов происходит в конец, но при этом часто к элементам коллекции обращаются по индексу, то безусловно выбор должен 
пасть на ArrayList. Если же при работе с коллекцией часто добавляют элементы в начало-середину и их также часто удаляют из начала-середины, то в этом случае необходимо выбрать 
LinkedList.

2. HashSet, LinkedHashSet and TreeSet.
Add test.
HashSet:       681700
LinkedHashSet: 671700
TreeSet:       923200

Search test.
HashSet:       719500
LinkedHashSet: 634300
TreeSet:      2564300

Delete test.
HashSet:      1892800
LinkedHashSet: 760300
TreeSet:      3767400

Выводы: В результате тестирования было получено, что HashSet по производительности по операциям добавления и поиска сравним с LinkedHashSet, однако, заметно проигрывает при 
удалении элементов, а TreeSet в свою очередь в 3 тестах показал наихудшее время.  Поэтому если для работы нужна коллекция, содержащая уникальные элементы, важна 
производительность, не важен порядок,а одна из самых частых операций - добавление элементов, то  следует выбрать HashSet. Если же важен порядок добавления элементов, 
то следует использовать LinkedHashSet. А если производительность не так важна, но при этом нужна упорядоченная коллекция, то можно использовать TreeSet.

3. HashMap, LinkedHashMap and TreeMap.
Add test.
HashMap:       171300
LinkedHashMap: 266400
TreeMap:       341900

Search key test.
HashMap:       430700
LinkedHashMap: 166600
TreeMap:      1264300

Search value test.
HashMap:       74542200
LinkedHashMap: 85072500
TreeMap:      123261400

Delete test.
HashMap:       602500
LinkedHashMap: 593600
TreeMap:      2387800
Выводы: В результате тестирования было выявлено, что HashMap следует использовать, если есть необходимость в коллекции, отображающей одно множество элементов на другое множество
элементов, наиболее частая операция с коллекцией - добавление, порядок не важен, а производительность играет не малую роль. LinkedHashMap имеет производительность схожую с 
HashMap, ее следует использовать, если для работы важен порядок добавления элементов. А TreeMap следует использовать, если появляется потребность в отсортированнай коллекции,
но при этом требования к производительности уже не занимают лидирующие позиции.
