Compare collections.

1. LinkedList and ArrayList
Результаты:
Add first.
ArrayList: 232577000
LinkedList: 2829800
Здесь результат ожидаемый, т.к. при вставке в начало ArrayList сдвигает все элементы, а LinkedList достаточно просто поменять ссылки.

Add last.
ArrayList:  2832300
LinkedList: 1748000
Показывают примерно одинаковый результат (одного порядка).

Add in the middle (Вставка в середину 1000 элементов)
ArrayList: 91498900
LinkedList: 3566190800
Ожидалось, что LinkedList отработает быстрее, т. к. ArrayList нужно сдвигать половину элементов. Но при тестировании получалось, что ArrayList отрабатывает быстрее. Увеличивал размеры коллекций до 1000000, вставлял в середину от 1 до 10000, но все равно ArrayList оказывался быстрее. Могу это объяснить это только тем, что при указанных размерах ArrayList быстрее сдвигает элементы, чем LinkedList добирается до элемента, у которого нужно поменять ссылки. Но если смещать индекс ближе к началу, то LinkedList быстрее начинает отрабатывать.

Search by index
ArrayList: 152300
LinkedList: 3167882500

Search by value
ArrayList:  4416813500
LinkedList: 7811285000

Delete
ArrayList: 67294600
LinkedList: 6905641000
Здесь опять такая же ситуация, как со вставкой в середину. Если индекс находится ближе к началу, то LinkedList намного быстрее ArrayList и по мере увеличения индекса скорость работы выравнивается, а затем опять начинает лидировать ArrayList

При поиске по значению показывают примерно одинаковый результат, ну и соответственно при поиске по индексу ArrayList намного быстрее, т.к. поддерживает произвольный доступ.

Выводы: Если при работе с коллекцией часто вставка элементов происходит в конец, но при этом часто к элементам коллекции обращаются по индексу, то безусловно выбор должен пасть на ArrayList. Если же при работе с коллекцией часто добавляют элементы в начало-середину и их также часто удаляют из начала-середину, то в этом случае необходимо выбрать LinkedList

2. HashSet, LinkedHashSet and TreeSet.
Add test.
HashSet:       681700
LinkedHashSet: 671700
TreeSet:       923200

Search test.
HashSet:       719500
LinkedHashSet: 634300
TreeSet:      2564300

Delete test.
HashSet:      1892800
LinkedHashSet: 760300
TreeSet:      3767400

Выводы: В результате тестирования было получено, что HashSet по производительности по операциям добавления и поиска сравним с LinkedHashSet, однако, заметно проигрывает при удалении элементов, а TreeSet в свою очередь в 3 тестах показал наихудшее время.  Поэтому если для работы нужна коллекция, содержащая уникальные элементы, важно производительность, не важен порядок,а одна из самых частых операций - добавление элементов, то  следует выбрать HashSet. Если же важен порядок добавления элементов, то следует использовать LinkedHashSet. А если производительность не так важна, но при этом нужна упорядоченная коллекция, то можно использовать TreeSet.

3. HashMap, LinkedHashMap and TreeMap.
Add test.
HashMap:       171300
LinkedHashMap: 266400
TreeMap:       341900

Search key test.
HashMap:       430700
LinkedHashMap: 166600
TreeMap:      1264300

Search value test.
HashMap:       74542200
LinkedHashMap: 85072500
TreeMap:      123261400

Delete test.
HashMap:       602500
LinkedHashMap: 593600
TreeMap:      2387800
Выводы: В результате тестирования было выявлено, что HashMap следует использовать, если есть необходимость в коллекции, отображающей одно множество элементов на другое множество элементов, наиболее частая операция с коллекцией - добавление, порядок не важен, а производительность играет не малую роль. LinkedHashMap имеет производительность схожую с HashMap, ее следует использовать, если для работы важен порядок добавления элементов. А TreeMap следует использовать, если появляется потребность в отсортированнай коллекции, но при этом требования к производительности уже не занимают лидирующие позиции.
