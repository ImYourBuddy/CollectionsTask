Compare collections.

1. LinkedList and ArrayList
Результаты:
Add first.
ArrayList: 232577000
LinkedList: 2829800
Здесь результат ожидаемый, т.к. при вставке в начало ArrayList сдвигает все элементы, а LinkedList достаточно просто поменять ссылки.

Add last.
ArrayList:  2832300
LinkedList: 1748000
Показывают примерно одинаковый результат (одного порядка).

Add in the middle (Вставка в середину 1000 элементов)
ArrayList: 91498900
LinkedList: 3566190800
Ожидалось, что LinkedList отработает быстрее, т. к. ArrayList нужно сдвигать половину элементов. Но при тестировании получалось, что ArrayList отрабатывает быстрее.
Увеличивал размеры коллекций до 1000000, вставлял в середину от 1 до 10000, но все равно ArrayList оказывался быстрее. Могу это объяснить это только тем, что при указанных размерах
ArrayList быстрее сдвигает элементы, чем LinkedList добирается до элемента, у которого нужно поменять ссылки. Но если смещать индекс ближе к началу, то LinkedList быстрее начинает отрабатывать.

Search by index
ArrayList: 152300
LinkedList: 3167882500

Search by value
ArrayList:  4416813500
LinkedList: 7811285000

Delete
ArrayList: 67294600
LinkedList: 6905641000
Здесь опять такая же ситуация, как со вставкой в середину. Если индекс находится ближе к началу, то LinkedList намного быстрее ArrayList и по мере увеличения индекса скорость работы выравнивается, а затем опять начинает лидировать ArrayList

При поиске по значению показывают примерно одинаковый результат, ну и соответственно при поиске по индексу ArrayList намного быстрее, т.к. поддерживает произвольный доступ.

Выводы: Если при работе с коллекцией часто вставка элементов происходит в конец, но при этом часто к элементам коллекции обращаются по индексу, то безусловно выбор должен пасть на ArrayList. Если же при работе с коллекцией часто добавляют элементы в начало-середину и их также часто удаляют из начала-середину, то в этом случае необходимо выбрать LinkedList

2. HashSet, LinkedHashSet and TreeSet.
Add test.
HashSet: 	    65500
LinkedHashSet: 575300
TreeSet:      2658800

Search test.
HashSet:       66600
LinkedHashSet: 69000
TreeSet:     2456500

Delete test.
HashSet:       168800
LinkedHashSet: 169300
TreeSet:       730100

Выводы: В результате тестирования было получено, что HashSet отрабатывает на вставку элементов быстрее остальных 2 коллекций, а 
поиск и удаление элементов по времени работы сравнимы с LinkedHashSet, а TreeSet в свою очередь в 3 тестах показал наихудшее время 
работы. Поэтому если для работы нужна коллекция, содержащая уникальные элементы, важно производительность и не важен порядок, то 
следует выбрать HashSet. Если же важен порядок добавления элементов, то следует использовать LinkedHashSet. А если 
производительность не так важна, но при этом нужна упорядоченная коллекция, то можно использовать TreeSet.

3. HashMap, LinkedHashMap and TreeMap.
Add test.
HashMap:       171300
LinkedHashMap: 266400
TreeMap:       341900

Search key test.
HashMap:       430700
LinkedHashMap: 166600
TreeMap:      1264300

Search value test.
HashMap:       74542200
LinkedHashMap: 85072500
TreeMap:      123261400

Delete test.
HashMap:       602500
LinkedHashMap: 593600
TreeMap:      2387800

Выводы: В результате тестирования было выявлено, что HashMap следует использовать, если есть необходимость в коллекции,
 отображающей одно множество элементов на другое множество элементов, наиболее частая операция с коллекцией - добавление, порядок
  не важен, а производительность играет не малую роль. LinkedHashMap следует использовать, если для работы важен порядок 
  добавления элементов. А TreeMap следует использовать, если появляется потребность в отсортированнай коллекции, но при этом 
  требования к производительности уже не занимают лидирующие позиции.
